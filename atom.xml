<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[iBlog]]></title>
  <link href="http://Ju6y.github.io/atom.xml" rel="self"/>
  <link href="http://Ju6y.github.io/"/>
  <updated>2013-09-10T17:47:10+08:00</updated>
  <id>http://Ju6y.github.io/</id>
  <author>
    <name><![CDATA[Ju6y]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[32位与64位系统下在python中使用struct模块的区别]]></title>
    <link href="http://Ju6y.github.io/blog/2013/09/10/32wei-yu-64wei-xi-tong-xia-zai-pythonzhong-shi-yong-structmo-kuai-de-qu-bie/"/>
    <updated>2013-09-10T13:31:00+08:00</updated>
    <id>http://Ju6y.github.io/blog/2013/09/10/32wei-yu-64wei-xi-tong-xia-zai-pythonzhong-shi-yong-structmo-kuai-de-qu-bie</id>
    <content type="html"><![CDATA[<p>今天有人问我，在32位系统下使用struct pack了一个数据在64位系统下unpack时报错，应该怎么解决。并且该32位系统部署了其他服务没法重装系统，同时运行在64位系统下的unpack代码也访问不到，唯一能做就是修改pack部分代码。代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>strData = struct.pack("36sQQ", strSession, llChips, 0)</span></code></pre></td></tr></table></div></figure>


<p>第一眼看了代码，觉得是pack &ldquo;Q&#8221;有问题，也就是打包<strong>unsigned long long</strong>类型的数据，即8个字节的无符号整型，映像中好像是32位系统不支持这么大的整型，于是决定下个python源码看看struct是怎么pack数据的。</p>

<p>看了会儿源码找到了打包<strong>unsigned long long</strong>类型的函数，发现了一个<strong>ifdef</strong>，这个<strong>ifdef</strong>来判断系统是否支持<strong>unsigned long long</strong>类型数据的pack，并且还附有一段注释：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* We can't support q and Q in native mode unless the compiler does;
</span><span class='line'>   in std mode, they're 8 bytes on all platforms. */
</span><span class='line'>ifdef HAVE_LONG_LONG
</span><span class='line'>typedef struct { char c; PY_LONG_LONG x; } s_long_long;
</span><span class='line'>#define LONG_LONG_ALIGN (sizeof(s_long_long) - sizeof(PY_LONG_LONG))
</span><span class='line'>#endif </span></code></pre></td></tr></table></div></figure>


<p>注释中说，标准模式下，所有平台的<strong>unsigned long long</strong>类型都是8字节，完全没提到32位或者64位，我心里一想不会是记错了吧，赶紧谷歌了一下，发现struct的官方文档对&#8221;Q&#8221;这个类型的平台支持进行了说明，如下：</p>

<blockquote><p>The &lsquo;q&rsquo; and &lsquo;Q&rsquo; conversion codes are available in native mode only if the platform C compiler supports C long long, or, on Windows, __int64. They are always available in standard modes.</p></blockquote>

<p>同样没提及64位和32位，我一想既然这样索性自己试一下就知道是不是支持了。于是找来了32位机器，在python命令行下试验了一下pack &ldquo;Q&#8221;类型数据，并对比了64位下的结果，完全没有区别，事实证明我之前对<strong>unsigned long long</strong>类型的理解是错的。既然打包“Q”类型没有问题，那这个unpack不了的问题又出在哪里呢，我猜想是不是字节对齐的问题，因为pack的时候会对数据进行字节补齐，于是继续看struct文档，下面是pack时，可以指定的字节序和对齐方式的标识：</p>

<table>
<thead>
<tr>
<th>Character </th>
<th> Byte order             </th>
<th> Size     </th>
<th> Alignment </th>
</tr>
</thead>
<tbody>
<tr>
<td>@         </td>
<td> native                 </td>
<td> native   </td>
<td> native    </td>
</tr>
<tr>
<td>=         </td>
<td> native                 </td>
<td> standard </td>
<td> none      </td>
</tr>
<tr>
<td>&lt;         </td>
<td> little-endian          </td>
<td> standard </td>
<td> none      </td>
</tr>
<tr>
<td>>        </td>
<td> big-endian             </td>
<td> standard </td>
<td> none      </td>
</tr>
<tr>
<td>!         </td>
<td> network (= big-endian) </td>
<td> standard </td>
<td> none      </td>
</tr>
</tbody>
</table>


<p>我们可以看到跟对齐关系有关的也就是2种，对齐和不对齐（这不废话么）。如果在pack函数的第一个参数fmt字符串最前面加了@就会使用字节对齐，另外需要注意的是，如果没有上面的任何一个符号，默认就是使用@，原文如下:</p>

<blockquote><p>If the first character is not one of these, &lsquo;@&rsquo; is assumed.</p></blockquote>

<p>看到这里可能有人会怀疑是字节序的问题，其实目前大部分平台都是使用小端序，即little-endian，只有少数平台使用big-endian，文档中也有说明：</p>

<blockquote><p>Native byte order is big-endian or little-endian, depending on the host system. For example, Intel x86 and AMD64 (x86-64) are little-endian; Motorola 68000 and PowerPC G5 are big-endian; ARM and Intel Itanium feature switchable endianness (bi-endian)</p></blockquote>

<p>可以看到如果使用的是Intel和AMD的CPU，那就是使用的小端序。</p>

<p>我们继续看字节对齐的问题，文档提到：</p>

<blockquote><p>Native size and alignment are determined using the C compiler’s <code>sizeof</code> expression.</p></blockquote>

<p>可以看到如何对齐取决于c编译器，一般也就是平台有关。经过一番查找，发现32位下是4字节对齐，64位下是8字节对齐，然后看到文章开头的pack代码里有个“36s”，36明显不能被8除尽，于是我对比了32位与64位下的pack结果：</p>

<p>32位:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;&gt;&gt; struct.pack('36sQQ', '1'*36, 1, 0)
</span><span class='line'>'111111111111111111111111111111111111\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'</span></code></pre></td></tr></table></div></figure>


<p>64位：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;&gt;&gt; struct.pack('36sQQ', '1'*36, 1, 0)
</span><span class='line'>'111111111111111111111111111111111111\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'</span></code></pre></td></tr></table></div></figure>


<p>可以发现，64位的&#8217;\x01&#8217;前多了4个空字节，这其实就是字节补齐的结果，到这里其实就知道怎么解决这个问题了，就是给32位的pack结果增加4个空白字节就行，可以用字符串拼接，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;&gt;&gt; struct.pack('36s', '1'*36) + '\x00\x00\x00\x00' + struct.pack('QQ', 1, 0)
</span><span class='line'>'111111111111111111111111111111111111\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'</span></code></pre></td></tr></table></div></figure>


<p>也可以直接指定为40个字符的字符串，如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;&gt;&gt; struct.pack('40sQQ', '1'*36, 1, 0)
</span><span class='line'>'111111111111111111111111111111111111\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git命令汇总]]></title>
    <link href="http://Ju6y.github.io/blog/2013/09/08/gitming-ling-hui-zong/"/>
    <updated>2013-09-08T22:28:00+08:00</updated>
    <id>http://Ju6y.github.io/blog/2013/09/08/gitming-ling-hui-zong</id>
    <content type="html"><![CDATA[<p>最近在看《Pro Git》，还没看完，命令实在太多，先把目前遇到的git命令画到思维导图里了，以后查找能方便些。</p>

<p>后面遇到其他命令再进行补充。</p>

<p><a href="https://raw.github.com/Ju6y/screenshots/master/git.png"><img src="https://raw.github.com/Ju6y/screenshots/master/git.png" alt="git mind map" /></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[virtualenv]]></title>
    <link href="http://Ju6y.github.io/blog/2013/09/03/virtualenv/"/>
    <updated>2013-09-03T23:04:00+08:00</updated>
    <id>http://Ju6y.github.io/blog/2013/09/03/virtualenv</id>
    <content type="html"><![CDATA[<p>如果一个生产环境中部署了多个项目，每个项目使用不同版本的Python，或者不同项目依赖同一个模块的不同版本；</p>

<p>如果你有洁癖，希望保证服务器默认环境的干净；</p>

<p>如果你想尝试某些新工具，又不希望因为这些工具安装失败而搞乱整个服务器环境</p>

<p>如果你会遇到如上几种情况，那么virtualenv无疑是你最好的选择。</p>

<h3>安装</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo easy_install virtualenv</span></code></pre></td></tr></table></div></figure>


<p>或者</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo pip install virtualenv</span></code></pre></td></tr></table></div></figure>


<h3>建立虚拟环境</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir myproject
</span><span class='line'>$ cd myproject
</span><span class='line'>$ virtualenv venv
</span><span class='line'>New python executable in venv/bin/python
</span><span class='line'>Installing distribute............done.</span></code></pre></td></tr></table></div></figure>


<h3>使用虚拟环境</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ . venv/bin/activate</span></code></pre></td></tr></table></div></figure>


<p>如果以uwsgi的方式启动，那么在uwsgi的配置中增加如下配置（ini格式，其他形式请查<a href="http://uwsgi-docs.readthedocs.org/en/latest/Options.html#home-virtualenv-venv-pyhome">官方文档</a>）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>virtualenv = myproject的全路径/venv</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tornado+uWSGI]]></title>
    <link href="http://Ju6y.github.io/blog/2013/09/03/tornado-plus-uwsgi/"/>
    <updated>2013-09-03T00:05:00+08:00</updated>
    <id>http://Ju6y.github.io/blog/2013/09/03/tornado-plus-uwsgi</id>
    <content type="html"><![CDATA[<p>＃使用Tornado＋uWSGI来处理HTTP请求</p>

<p>一个简单的响应“hello world”的例子如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/usr/bin/env python
</span><span class='line'>#-*-coding:utf-8-*-
</span><span class='line'>
</span><span class='line'>import tornado.web
</span><span class='line'>import tornado.wsgi
</span><span class='line'>
</span><span class='line'>class handle(tornado.web.RequestHandler):
</span><span class='line'>    def initialize(self):
</span><span class='line'>        self.name = ''
</span><span class='line'>
</span><span class='line'>    def get(self):
</span><span class='line'>        self.name = self.get_argument("name", "nobody")
</span><span class='line'>        uid = self.get_cookie("uid", 0) + 1
</span><span class='line'>        self.set_cookie("uid", str(uid))
</span><span class='line'>        self.set_header("New-Header", "Yes")
</span><span class='line'>        self.write("hello %s" % self.name)
</span><span class='line'>
</span><span class='line'>    def post(self):
</span><span class='line'>        self.name = self.get_argument("name", "nobody")
</span><span class='line'>        self.set_status(405, "")
</span><span class='line'>        self.write("sorry, %s" % self.name)
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>application = tornado.wsgi.WSGIApplication([
</span><span class='line'>    (r'/hello', handle),
</span><span class='line'>])</span></code></pre></td></tr></table></div></figure>


<p>例子虽然比较简单，但一些常用的功能都覆盖到了，请求参数的获取、cookie的获取和设置、url map的定义等。获取请求参数的方式跟webpy类似，GET方式和POST方式都是通过一个API来获取，跟flask中的有点区别。</p>

<p>另外需要说明的是，像上面例子中那样定义一个handle类来处理请求的话，必须要继承tornado.web.RequestHandler，并且不能自己在定义__init__函数，如果有初始化工作要做，就定义一个initialize函数，把初始化工作都放到这个函数里，这个函数会在tornado.web.RequestHandler的__init__函数的最后被调用。实际使用起来跟__init__函数没有太大区别。</p>

<p>还有一点跟webpy不一样的是，例子中的handle不能是函数，必须是个继承tornado.web.RequestHandler的类。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python中的字符编码处理]]></title>
    <link href="http://Ju6y.github.io/blog/2013/09/03/pythonzhong-de-zi-fu-bian-ma-chu-li/"/>
    <updated>2013-09-03T00:00:00+08:00</updated>
    <id>http://Ju6y.github.io/blog/2013/09/03/pythonzhong-de-zi-fu-bian-ma-chu-li</id>
    <content type="html"><![CDATA[<p>相信那些经常使用Python处理中文或者其他非西文字符的人都多多少少被字符的编码转换困扰过。当然，只要是国内的程序员，不管你使用哪种编程语言都会遇到字符编码转换的问题，但这个问题在Python中更为突出。</p>

<p>我们知道在Python内部和许多第三方模块内部，字符串都默认是使用unicode来表示的（Python 2.x中字符串分为str类型和unicode类型，本文提到的带编码的字符串都是指str类型，而提到的unicode编码的字符串都是指unicode类型），也就是说，你传入一个字符串给一个内置函数或者第三方模块的接口，它们内部会事先将字符串的编码转换为unicode，而unicode最常见的实现方式是utf8编码（关于更多的字符编码信息请自行谷歌），所以这些函数通常会将获得的字符串参数默认为utf8编码，并尝试解码为unicode，这就导致了如果你传入的是非utf8编码的字符串，调用这些接口就会抛出异常，终止你的代码。</p>

<p>所以为了能正常调度这些接口，需要每次传入正确编码的字符串。众所周知，有个比较强大的Python第三方模块chardet，使用这个模块就能很方便的检测出大部分的字符串的字符编码。但这个模块存在2个问题，至少是我工作中遇到的比较显著的2个问题：第一，检测较长的字符串时（例如一个文本文件的编码）性能不太好，比较慢；第二，只要一个字符串中混入了一个字节的错误编码就会导致整个字符串的字符编码检测不出来。</p>

<p>下面是我针对这2个问题的优化方案（所有测试都是在Python 2.7.2中进行，系统OS X 10.8.4）<strong><em>(2013-09-03更新)</em></strong>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def to_unicode(string):
</span><span class='line'>    #1
</span><span class='line'>    if isinstance(string, unicode):
</span><span class='line'>        return string
</span><span class='line'>    try:
</span><span class='line'>        string_uni = string.decode("UTF-8")
</span><span class='line'>        return string_uni
</span><span class='line'>    except UnicodeDecodeError:
</span><span class='line'>        pass
</span><span class='line'>    
</span><span class='line'>    #2
</span><span class='line'>    INIT = 1000
</span><span class='line'>    MAX = 10
</span><span class='line'>    charset = None
</span><span class='line'>    if len(string) &lt;= INIT: 
</span><span class='line'>        encoding_info = chardet.detect(string)
</span><span class='line'>        charset = encoding_info['encoding']
</span><span class='line'>    else:
</span><span class='line'>        detector = UniversalDetector()
</span><span class='line'>        for i in range(MAX):
</span><span class='line'>            detector.feed(string[INIT*i:INIT*(i+1)])
</span><span class='line'>            if detector.done:
</span><span class='line'>                break
</span><span class='line'>        detector.close()
</span><span class='line'>        charset = detector.result.get('encoding')
</span><span class='line'>    #3
</span><span class='line'>    if not charset:
</span><span class='line'>        INIT = 1
</span><span class='line'>        MAX = 100
</span><span class='line'>        detector = UniversalDetector()
</span><span class='line'>        for i in range(MAX):
</span><span class='line'>            detector.feed(string[INIT*i:INIT*(i+1)])
</span><span class='line'>            if detector.done:
</span><span class='line'>                mylog.LOG.ERROR("decode char one by one worked!")
</span><span class='line'>                break
</span><span class='line'>        detector.close()
</span><span class='line'>        charset = detector.result.get('encoding')
</span><span class='line'>    #4
</span><span class='line'>    if not charset:
</span><span class='line'>        return string.decode('UTF-8', 'ignore')
</span><span class='line'>    elif charset[:2].upper() == 'GB':
</span><span class='line'>        charset = 'GB18030'
</span><span class='line'>    #5
</span><span class='line'>    try:
</span><span class='line'>        return string.decode(charset, 'replace')
</span><span class='line'>    except UnicodeDecodeError:
</span><span class='line'>        mylog.LOG.ERROR(traceback.format_exc())
</span><span class='line'>        return string</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>这个函数的功能是将一个字符串转为unicode类型，下面来解释下这段代码： <del>第一部分先用最常见的几个中文字符编码尝试去解码字符串</del>，<em>第一部分先判断是否是unicode，来作兼容，因为如果传入的字符串本身就已经是unicode了，下面的代码都执行不了，然后先强制作utf8解码，(2013-09-03新加)</em>这是考虑到使用chardet的性能问题，因为直接调用decode函数的成本会比使用chardet.detect成本低很多。<del>如果解码成功就返回，这几行代码基本能处理大部分的字符串。这里需要注意下几个编码的尝试顺序，必须将gb18030放在最后，因为偶数个字节的utf8编码字符串或者big5编码字符串都能被gb18030解码而不抛出异常，当然解码的结果是错误的。</del>
<em>这里去掉了big5和gb18030编码的强行解码，因为发现gb18030编码的字符串可以被big5解码而不报错，反之亦然。至于原因目前还没搞懂，只知道gb2312是gbk的子集，gbk是gb18030的子集，各自都向下兼容。(2013-09-03更新)</em></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;&gt;&gt; a = '中文'
</span><span class='line'>&gt;&gt;&gt; a
</span><span class='line'>'\xe4\xb8\xad\xe6\x96\x87'
</span><span class='line'>&gt;&gt;&gt; print a.decode('gb18030')
</span><span class='line'>涓枃
</span><span class='line'>&gt;&gt;&gt; b = a.decode('utf8').encode('big5')
</span><span class='line'>&gt;&gt;&gt; b
</span><span class='line'>'\xa4\xa4\xa4\xe5'
</span><span class='line'>&gt;&gt;&gt; b.decode('gb18030')
</span><span class='line'>u'\u3044\u3085'
</span><span class='line'>&gt;&gt;&gt; print b.decode('gb18030')
</span><span class='line'>いゅ
</span><span class='line'>&gt;&gt;&gt; c = a.decode('utf8').encode('gb18030')
</span><span class='line'>&gt;&gt;&gt; c
</span><span class='line'>'\xd6\xd0\xce\xc4'
</span><span class='line'>&gt;&gt;&gt; print c.decode('big5')
</span><span class='line'>笢恅</span></code></pre></td></tr></table></div></figure>


<p>如果是奇数个字节的utf8编码字符串就不能被gb18030解码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;&gt;&gt; c = '中文字'
</span><span class='line'>&gt;&gt;&gt; c
</span><span class='line'>'\xe4\xb8\xad\xe6\x96\x87\xe5\xad\x97'
</span><span class='line'>&gt;&gt;&gt; c.decode('gb18030')
</span><span class='line'>Traceback (most recent call last):
</span><span class='line'>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
</span><span class='line'>UnicodeDecodeError: 'gb18030' codec can't decode byte 0x97 in position 8: incomplete multibyte sequence</span></code></pre></td></tr></table></div></figure>


<p>这里使用gb18030，而没有使用gbk或者gb2312，是因为gb18030是后两者的超集。</p>

<p>第二部分中，对长度小于1000的字符串直接使用detect函数进行编码检测，而超过100的同样是考虑性能问题，采用了每次增量检测长度100的字符串，最多增加9次，即限制检测的最大的长度为1000，如果能提前确定了编码，就会跳出循环，避免了对大字符串的整体检测，因为一个字符串往往都是同一种编码。</p>

<p>第三部分中，如果第二部检测不到编码结果，往往是遇到了字符串中混有错误编码的情况，那么对字符串的前100个字符逐个检测，直到检测出编码或者检测完100个字符为止。检测完毕如果还是未检测出编码，就使用utf8解码，并传入‘ignore’，跳过不能解码的字节，减小错误编码造成的影响。</p>

<p>这里补充下decode函数的说明：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>decode(...)
</span><span class='line'>    S.decode([encoding[,errors]]) -&gt; object
</span><span class='line'>      
</span><span class='line'>    Decodes S using the codec registered for encoding. encoding defaults
</span><span class='line'>    to the default encoding. errors may be given to set a different error
</span><span class='line'>    handling scheme. Default is 'strict' meaning that encoding errors raise
</span><span class='line'>    a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'
</span><span class='line'>    as well as any other name registered with codecs.register_error that is
</span><span class='line'>    able to handle UnicodeDecodeErrors.</span></code></pre></td></tr></table></div></figure>


<p>上面是使用help查看decode函数的内置说明，可以看到调用decode，如果只传入编码信息，默认的异常处理模式为strict，只要遇到不能解码的就会抛出UnicodeDecodeError异常，另外你可以传入ignore来跳过不能解码的字节，或者replace来强制使用指定的编码解码。这个异常处理模式的指定，在encode函数中也同样适用。</p>

<p>例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;&gt;&gt; '中文'
</span><span class='line'>'\xe4\xb8\xad\xe6\x96\x87'
</span><span class='line'>&gt;&gt;&gt; '中文'.decode('utf8')
</span><span class='line'>u'\u4e2d\u6587'</span></code></pre></td></tr></table></div></figure>


<p>手动在上面utf8编码的字符串中混入一个错误编码，并且已经无法正常使用utf8解码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;&gt;&gt; d = '\xe4\xb8\xad\xdd\xe6\x96\x87'
</span><span class='line'>&gt;&gt;&gt; d
</span><span class='line'>'\xe4\xb8\xad\xdd\xe6\x96\x87'
</span><span class='line'>&gt;&gt;&gt; print d
</span><span class='line'>中?文
</span><span class='line'>&gt;&gt;&gt; d.decode('utf8')
</span><span class='line'>Traceback (most recent call last):
</span><span class='line'>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
</span><span class='line'>  File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/encodings/utf_8.py", line 16, in decode
</span><span class='line'>    return codecs.utf_8_decode(input, errors, True)
</span><span class='line'>UnicodeDecodeError: 'utf8' codec can't decode byte 0xdd in position 3: invalid continuation byte</span></code></pre></td></tr></table></div></figure>


<p>下面测试下使用ingore和replace后的不同</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;&gt;&gt; d.decode('utf8', 'ignore')
</span><span class='line'>u'\u4e2d\u6587'
</span><span class='line'>&gt;&gt;&gt; print d.decode('utf8', 'ignore')
</span><span class='line'>中文
</span><span class='line'>&gt;&gt;&gt; d.decode('utf8', 'replace')
</span><span class='line'>u'\u4e2d\ufffd\u6587'
</span><span class='line'>&gt;&gt;&gt; print d.decode('utf8', 'replace')
</span><span class='line'>中�文
</span><span class='line'>&gt;&gt;&gt; '中文'.decode('utf8')
</span><span class='line'>u'\u4e2d\u6587'</span></code></pre></td></tr></table></div></figure>


<p>发现，使用ignore正确地跳过了错误编码，使用replace则会将那个错误编码强制转换，造成乱码。</p>

<p><em>第4部分中，不知道是不是chardet的bug，如果是gb18030编码的字符串会被检测成为gb2312，而gb2312的字符集要比gb18030小，导致某些生僻字解码出错，这个函数里如果遇到是gb字符集都统一用gb18030去解码，保证解码成功。(2013-09-03更新)</em></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;&gt;&gt; a = '中文阿舒服的沙发法撒爹翻爾薾'.decode('utf8').encode('gb18030')
</span><span class='line'>&gt;&gt;&gt; chardet.detect(a)
</span><span class='line'>{'confidence': 0.99, 'encoding': 'GB2312'}
</span><span class='line'>&gt;&gt;&gt; print a.decode('gb2312')
</span><span class='line'>Traceback (most recent call last):
</span><span class='line'>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
</span><span class='line'>UnicodeDecodeError: 'gb2312' codec can't decode bytes in position 24-25: illegal multibyte sequence</span></code></pre></td></tr></table></div></figure>


<p>再回到上面的函数代码，第五部分中，不管之前有没有检测出编码，都会对字符串进行强制解码，当然保险起见，这里还加了try，来捕获有可能抛出的异常。</p>

<p>最后，虽然字符编码问题很令人头疼，但只要耐心搞清楚背后的原理，处理起来也没有想象中那么困难。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PEP 8翻译]]></title>
    <link href="http://Ju6y.github.io/blog/2013/07/07/pep-8/"/>
    <updated>2013-07-07T16:08:00+08:00</updated>
    <id>http://Ju6y.github.io/blog/2013/07/07/pep-8</id>
    <content type="html"><![CDATA[<h1>PEP<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 8</h1>

<h3>Python代码风格指导</h3>

<h3>原文链接<a href="http://www.python.org/dev/peps/pep-0008/#id8">http://www.python.org/dev/peps/pep-0008/#id8</a></h3>

<h2>介绍</h2>

<p>这个文档提供了主要的Python发行版本中标准库代码的风格规范。可以同时参考C代码风格指南<a href="http://www.python.org/dev/peps/pep-0007/">PEP 7</a>。
这个文档和<a href="http://www.python.org/dev/peps/pep-0257/">PEP 257(docstring的编写指南)</a>是从Guido最早的Python编码风格指导论文改编而来，并在此之上增加了部分Barry的风格指导（<a href="http://barry.warsaw.us/software/STYLEGUIDE.txt">Barry&rsquo;s GNU Mailman style guide</a>）</p>

<h2>愚蠢地坚持随波逐流是心胸狭窄的表现(A Foolish Consistency is the Hobgoblin of Little Minds)</h2>

<p>Guido的主要观点之一是代码更多的时候是用来读的。这篇指南旨在提高代码的可读性，并使大部分的Python代码的风格都能够保持一致性。就像<a href="http://www.python.org/dev/peps/pep-0020/">PEP 20（Python之禅）</a>里提到的，“Readability counts”（可读性很重要）。</p>

<p>一种代码风格指南说白了就是保持一致性。在代码风格指南中保持风格的一致性很重要，在一个项目中保持一致性更是如此，在一个模块或者一个函数中保持代码风格的一致性尤甚。</p>

<p>但更重要的是要知道什么时候该放弃一致性，有的时候风格指南并不适用。当对是否要应用风格指南有疑问时，你应该相信自己的最佳判断，也可以查看其他例子，决定什么样的才是看上去最好的，还有要会及时提问。</p>

<p>有2个理由可以让你不遵守某个规则：</p>

<p>1.应用这个规则会降低代码的可读性，即使是对那些习惯了这个规则的代码阅读者</p>

<p>2.为了与原有代码保持一致（也许是历史原因）&mdash; 虽然这是一个绝佳的机会来收拾别人的烂摊子（真正的XP风格，XP，Xtreme Programming，极限编程）</p>

<h2>代码布局</h2>

<h3>缩进</h3>

<p>使用4个空格来进行每一级的缩进。
为了与那些很老的代码保持一致，你可以继续使用8空格长的制表符。</p>

<p>续行应该通过使用小括号、中括号、大括号中隐式续行垂直的排列元素，或者使用一个悬挂的缩进。当使用悬挂缩进时，需要注意如下几点：第一行中不应该放参数，使用进一步的缩进来区分这一行是续行。</p>

<p>YES：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#跟开始的圆括号对齐
</span><span class='line'>foo = long_function_name(var_one, var_two,
</span><span class='line'>                         var_three, var_four)
</span><span class='line'>#多缩进一次来进行区分
</span><span class='line'>def long_function_name(
</span><span class='line'>        var_one, var_two, var_three,
</span><span class='line'>        var_four):
</span><span class='line'>    print(var_one)</span></code></pre></td></tr></table></div></figure>


<p>NO：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#当没有垂直对齐时，是不允许将参数放在第一行的
</span><span class='line'>foo = long_function_name(var_one, var_two,
</span><span class='line'>    var_three, var_four)
</span><span class='line'>#需要更进一步的缩进来与其他正常行的缩进区分开
</span><span class='line'>def long_function_name(
</span><span class='line'>    var_one, var_two, var_three,
</span><span class='line'>    var_four):
</span><span class='line'>    print(var_one)</span></code></pre></td></tr></table></div></figure>


<p>Optional：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># 更多的缩进也不是必须的
</span><span class='line'>foo = long_function_name(
</span><span class='line'>  var_one, var_two,
</span><span class='line'>  var_three, var_four)</span></code></pre></td></tr></table></div></figure>


<p>多行结构的右括号（包括圆括号、方括号、花括号）可以放在在列表中最后一个元素的下面，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>my_list = [
</span><span class='line'>    1, 2, 3,
</span><span class='line'>    4, 5, 6,
</span><span class='line'>    ]
</span><span class='line'>result = some_function_that_takes_arguments(
</span><span class='line'>    'a', 'b', 'c',
</span><span class='line'>    'd', 'e', 'f',
</span><span class='line'>    )</span></code></pre></td></tr></table></div></figure>


<p>也可以放在多行结构的行头下面，如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>my_list = [
</span><span class='line'>    1, 2, 3,
</span><span class='line'>    4, 5, 6,
</span><span class='line'>]
</span><span class='line'>result = some_function_that_takes_arguments(
</span><span class='line'>    'a', 'b', 'c',
</span><span class='line'>    'd', 'e', 'f',
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<h3>制表符还是空格</h3>

<p>永远不要将制表符和空格混合使用。</p>

<p>Python缩进的最常用方式是只使用空格。第二常用的是只使用制表符。混合使用空格和制表符进行缩进的代码都应该专门处理成用空格缩进。在使用Python命令行时，使用-t选项将会对混合空格和制表符的缩进进行警告，如果是用-tt选项，这些警告就会变成错误。强烈建议使用这些选项。</p>

<p>对于新项目，强烈建议使用空格作为唯一的缩进方式，很多编辑器都能够设置将tab映射为多个空格，使得使用空格来缩进变得很容易使用。</p>

<h3>最大行字符数</h3>

<p>将每一行的最大字符数都限制到79个。</p>

<p>现在仍然有很多设备限制每行最多只能显示80个字符，此外，限制窗口到80个字符，能够方便将多个窗口并排显示。拥有这些限制的设备在显示代码的时候会打乱代码结构，使得代码难以理解，所以最好还是限制行最大字符数为79。对于那些连续的文字快（docstring或者注释）建议限制长度到72个字符。</p>

<p>较长行折行的首选方式是在圆括号、方括号、花括号中使用Python隐式续行。较长行可以在圆括号中分解为多行显示。这些操作应比反斜杠优先使用。同时要对续行进行适当地缩进。应该优先在二元操作符的后面对较长行进行折行，而不是二元操作符的前面，如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Rectangle(Blob):
</span><span class='line'>
</span><span class='line'>    def __init__(self, width, height,
</span><span class='line'>                 color='black', emphasis=None, highlight=0):
</span><span class='line'>        if (width == 0 and height == 0 and
</span><span class='line'>            color == 'red' and emphasis == 'strong' or
</span><span class='line'>            highlight &gt; 100):
</span><span class='line'>            raise ValueError("sorry, you lose")
</span><span class='line'>        if width == 0 and height == 0 and (color == 'red' or
</span><span class='line'>                                           emphasis is None):
</span><span class='line'>            raise ValueError("I don't think so -- values are %s, %s" %
</span><span class='line'>                             (width, height))
</span><span class='line'>        Blob.__init__(self, width, height,
</span><span class='line'>                      color, emphasis, highlight)</span></code></pre></td></tr></table></div></figure>


<h3>空行</h3>

<p>顶层单独的函数定义或类定义之间应间隔2个空白行。</p>

<p>类中的函数定义应使用1个空白行间隔开。</p>

<p>（谨慎地）使用额外的空白行来分隔一组相关的函数。一堆相关的单行代码间的空行应该被省略。</p>

<p>在函数中，谨慎地使用空白行来划分逻辑段落。</p>

<p>Python接收control-L换页符来作为空格。很多工具都把这些字符当作换页符，所以你可以使用它们来划分你代码文件中不同的段落。请注意，一些编辑器和基于Web的代码阅读器可能无法识别control-L为换页，将在其位置显示另一个字符。</p>

<h3>编码（<a href="http://www.python.org/dev/peps/pep-0263/">PEP263</a>）</h3>

<p>Python的主要发行版本代码中的编码应该一直使用ASCII或者latin-1（又名ISO-8859-1）。Python3.0及以后，将优先使用UTF-8。</p>

<p>使用ASCII编码的文件不应该带有coding cookie（# &ndash;*&ndash; coding: utf-8 &ndash;*-，# coding=utf-8）。latin-1或者utf-8只应该在一段注释或者文档字符设计到包含latin-1或者utf-8字符的作者名字时才使用，其他情况使用\x, \u 或者 \U等转义字符来表示非ASCII编码的字符串。</p>

<h3>导入</h3>

<p>每个import应该单独一行使用，如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Yes: import os
</span><span class='line'>     import sys
</span><span class='line'>No:  import sys, os</span></code></pre></td></tr></table></div></figure>


<p>如下使用是允许的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>from subprocess import Popen, PIPE</span></code></pre></td></tr></table></div></figure>


<p>import永远放在文件的顶部，仅仅在模块注释和文档字符串的后面，但在模块全局变量和常量的前面。</p>

<p>import应该按以下顺序分组和排列：</p>

<p>1.标准库导入</p>

<p>2.相关的第三方库导入</p>

<p>3.本地应用或库的特定导入</p>

<p>你应该在每一个组之间用一个空白行分隔开。</p>

<p>将任何相关联的<strong>all</strong>说明放到import后面。</p>

<p>非常不推荐在包内导入中使用相对路径导入，应该永远使用绝对路径导入。尽管现在<a href="http://www.python.org/dev/peps/pep-0328/">PEP 328</a>已经在Python2.5中实现，但依旧不鼓励使用相对路径导入风格，绝对路径导入更容易移植，往往可读性也更好。</p>

<p>从一个模块导入一个类时，往往这么写：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>from myclass import MyClass
</span><span class='line'>from foo.bar.yourclass import YourClass</span></code></pre></td></tr></table></div></figure>


<p>如果上述写法引起本地变量名冲突，那你应该这么写：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import myclass
</span><span class='line'>import foo.bar.yourclass</span></code></pre></td></tr></table></div></figure>


<p>然后使用 &ldquo;myclass.MyClass&#8221;和&#8221;foo.bar.yourclass.YourClass&#8221;。</p>

<h2>表达式和语句中的空格</h2>

<h3>无法忍受的事</h3>

<p>避免在下列情况中使用额外的空格</p>

<ul>
<li>紧贴圆括号、方括号、花括号</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Yes: spam(ham[1], {eggs: 2})
</span><span class='line'>No:  spam( ham[ 1 ], { eggs: 2 } )</span></code></pre></td></tr></table></div></figure>


<ul>
<li>逗号、冒号和分号之前不要有空格</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Yes: if x == 4: print x, y; x, y = y, x
</span><span class='line'>No:  if x == 4 : print x , y ; x , y = y , x</span></code></pre></td></tr></table></div></figure>


<ul>
<li>函数名与参数列表的左括号之间不要有空格</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Yes: spam(1)
</span><span class='line'>No:  spam (1)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>索引或分片的方括号之前不要有空格</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Yes: dict['key'] = list[index]
</span><span class='line'>No:  dict ['key'] = list [index]</span></code></pre></td></tr></table></div></figure>


<ul>
<li>不要为了对齐而在赋值（或其他）运算符的两边增加多个空格</li>
</ul>


<p>Yes:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>x = 1
</span><span class='line'>y = 2
</span><span class='line'>long_variable = 3</span></code></pre></td></tr></table></div></figure>


<p>No:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>x             = 1
</span><span class='line'>y             = 2
</span><span class='line'>long_variable = 3</span></code></pre></td></tr></table></div></figure>


<h3>其他建议</h3>

<ul>
<li><p>永远在二元操作符的2边放置一个空格</p></li>
<li><p>如果使用了不同优先级的多个操作符，可以考虑在最低优先级的操作符两边加空格。具体情况自己判断，然而不要使用超过一个空格，并且操作符两边的空格数量一定要一致。</p></li>
</ul>


<p>Yes:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>i = i + 1
</span><span class='line'>submitted += 1
</span><span class='line'>x = x*2 - 1
</span><span class='line'>hypot2 = x*x + y*y
</span><span class='line'>c = (a+b) * (a-b)</span></code></pre></td></tr></table></div></figure>


<p>No:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>i=i+1
</span><span class='line'>submitted +=1
</span><span class='line'>x = x * 2 - 1
</span><span class='line'>hypot2 = x * x + y * y
</span><span class='line'>c = (a + b) * (a - b)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>不要在一个关键字参数或者缺省参数的=号前后加空格</li>
</ul>


<p>Yes:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def complex(real, imag=0.0):
</span><span class='line'>    return magic(r=real, i=imag)</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>No:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def complex(real, imag = 0.0):
</span><span class='line'>    return magic(r = real, i = imag)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>一般不建议在同一行使用混合语句</li>
</ul>


<p>Yes:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if foo == 'blah':
</span><span class='line'>    do_blah_thing()
</span><span class='line'>do_one()
</span><span class='line'>do_two()
</span><span class='line'>do_three()</span></code></pre></td></tr></table></div></figure>


<p>宁愿不:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if foo == 'blah': do_blah_thing()
</span><span class='line'>do_one(); do_two(); do_three()</span></code></pre></td></tr></table></div></figure>


<ul>
<li>有时候将一个小的if/for/while块放在同一行是可以的，但是绝对不要将多个分句放在一行。不放在一行上，同时也能避免去折叠较长行。</li>
</ul>


<p>宁愿不:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if foo == 'blah': do_blah_thing()
</span><span class='line'>for x in lst: total += x
</span><span class='line'>while t &lt; 10: t = delay()</span></code></pre></td></tr></table></div></figure>


<p>一定不要:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if foo == 'blah': do_blah_thing()
</span><span class='line'>else: do_non_blah_thing()
</span><span class='line'>
</span><span class='line'>try: something()
</span><span class='line'>finally: cleanup()
</span><span class='line'>
</span><span class='line'>do_one(); do_two(); do_three(long, argument,
</span><span class='line'>                             list, like, this)
</span><span class='line'>
</span><span class='line'>if foo == 'blah': one(); two(); three()</span></code></pre></td></tr></table></div></figure>


<h2>注释</h2>

<p>与代码矛盾的注释比没有注释还糟糕。当代码改变时，永远优先更新注释。</p>

<p>注释应该是一个完整的句子。当注释是一句短语或者一句完整的句子的时候，句子的首字母应该大写（英文注释），除非是个以小写字母开头的标识（永远不要改变标识的大小写！）。</p>

<p>如果注释比较简单，最后的句号可以省略。注释块通常是由完整的语句构成的段落组成，每个语句都应该以句号结尾。</p>

<p>你应该在一句以句号结尾的句子后面加2个空格。</p>

<p>当写英文注释的时候，请使用“Strunk and White”<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>写作风格。</p>

<p>如果是非英语母语国家的Python程序员，请使用英文写注释，除非你120%保证你的代码永远不会被不说你的语言的人阅读。</p>

<h3>块注释</h3>

<p>块注释往往放在一段代码或者所有代码的前面，它和代码处在同一级缩进上。块注释的每一行都以#和紧跟的空格开始（除非是注释块中的缩进文本）。</p>

<p>块注释中的段落由以#开始的空白行分隔。</p>

<h3>行内注释</h3>

<p>谨慎使用行内注释</p>

<p>行内注释是指跟语句处在同一行的注释。行内注释与语句使用至少2个空格来进行分隔。行内注释由#和紧跟的空格开始。</p>

<p>如果行内注释描述的是显而易见的事，那么是不必要的甚至造成干扰：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>x = x + 1                 # Increment x</span></code></pre></td></tr></table></div></figure>


<p>但有时候是有用的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>x = x + 1                 # Compensate for border</span></code></pre></td></tr></table></div></figure>


<h3>文档字符串</h3>

<p>如何写出良好的文档字符串的规范可以查看<a href="http://www.python.org/dev/peps/pep-0257/">PEP 257</a></p>

<ul>
<li>为所有公共的模块、函数、类和方法写文档字符串。对于非公共的方法，文档字符串不是必须的，但你应该写一个注释来描述该方法，这个注释应该放在def行后面。</li>
<li>PEP 257描述了良好的文档字符串编写规范。其中最重要的是，&#8221;&ldquo;&#8221;作为多行文档字符串的结束时，应该单独起一行，之前还需要有一行空行。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"""Return a foobang
</span><span class='line'>
</span><span class='line'>Optional plotz says to frobnicate the bizbaz first.
</span><span class='line'>
</span><span class='line'>"""</span></code></pre></td></tr></table></div></figure>


<ul>
<li>如果是单行的文档字符串，可以不用将结束的&#8221;&ldquo;&#8221;单独放置一行。</li>
</ul>


<h2>版本注记</h2>

<p>如果在代码源文件中掺杂着Subversion，CVS或RCS注记，按照下面的规则书写。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>__version__ = "$Revision: cfd6d2cb1ca6 $"
</span><span class='line'># $Source$</span></code></pre></td></tr></table></div></figure>


<p>这些行应放在块注释之后，其他代码之前。前后各有一个空行。</p>

<h2>命名规范</h2>

<p>Python库中的命名规范有点混乱，所以我们永远无法将所有代码都保持一致。下面提供了当前比较推荐的命名标准。新的模块和包（包括第三方库）应该遵循这些标准，但是如果使用了不同风格的库，那么应该跟它们的风格保持一致。</p>

<h3>非限制性的：命名风格</h3>

<p>存在许许多多不同的命名风格，如果能识别出使用了哪种命名风格是很有用的，至于为什么要使用这种风格就不是那么重要了。</p>

<p>下面是一些比较常见的命名风格，这些风格的特征比较明显：</p>

<ul>
<li>b（单个小些字母）</li>
<li>B（单个大写字母）</li>
<li>lowercase（纯小写单词）</li>
<li>lower_case_with_underscores（使用下划线分隔的纯小写单词）</li>
<li>UPPERCASE（纯大写单词）</li>
<li>UPPER_CASE_WITH_UNDERSCORES（使用下划线分隔的纯大写单词）</li>
<li>CapitalizedWords 驼峰命名法（或CapWords，或CamelCase &ndash; 这么命名是因为单词上下起伏类似骆驼的背）有时也称为StudlyCaps。</li>
</ul>


<p><em>注意</em>：在CapWords中使用缩写时，请将缩写都大写，如HTTPServerError比HttpServerError更好</p>

<ul>
<li>mixedCase（与CapitalizedWords不同的是，首字母是小写）</li>
<li>Capitalized_Words_With_Underscores（就一个字，丑！）</li>
</ul>


<p>也有使用同一前缀来命名相关联名称的风格，但在Python中不常用，但为了表述的完整性还是要提一下。比如os.stat() 函数返回一个元组，包含了很多传统方式的命名如st_mode, st_size, st_mtime等（这么做是为了与POSIX系统调用结构体中字段保持一致，帮助程序员能够快速熟悉这些字段）。</p>

<p>X11库为所有的函数使用了X前缀。在Python中，这个一般是不需要的，因为属性和方法名都有对象作前缀，而函数名有模块名作前缀。</p>

<p>此外，下面的使用下划线为开头和结尾的特殊形式是公认的（通常能够跟任何风格兼容）
&ndash; _single_leading_underscore：弱内部使用指示，例如from M import *不会导入下划线开头的名称
&ndash; single_trailing_underscore_：规定用来避免与Python关键字冲突，如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Tkinter.Toplevel(master, class_='ClassName')</span></code></pre></td></tr></table></div></figure>


<ul>
<li>__double_leading_underscore：命名一个类属性时，触发调用“名字扩展”（inside class FooBar, __boo becomes _FooBar__boo）</li>
<li>__double_leading_and_trailing_underscore__：神奇的对象或属性，只存在于用户控制的命名空间内，如__init__, __import__ 或 __file__，永远不要创建类似名字，只使用文档中已记载的名字。</li>
</ul>


<h3>规定的：命名规范</h3>

<h4>避免使用的名字</h4>

<p>永远不要使用字符“l”（小写字母el），“O”（大写字母oh）和 “I”（大写字母eye）作为单字符名字。</p>

<p>在一些字体中，这些字符跟数字1和0很难区分，如果非要使用“l”，可以用“L”来代替。</p>

<h4>包和模块名</h4>

<p>模块名应该是较短，且全部由小写字母构成。如果能提升可读性，可以在模块名中增加下划线。包也同样使用较短的小写字母名字，但是不建议使用下划线。</p>

<p>因为模块名是隐射到文件名，一些文件系统是不区分大小写并且会截断较长的文件名。选择一个短的名字作为模块名是很重要的&mdash;但在Unix下不会有问题，如果代码移植到老的Mac、windows或者DOS就可能引起问题。</p>

<p>当一个C/C++编写的扩展模块，使用Python模块作为高层的接口时，C/C++模块名前应该加下划线（例如：_socket）。</p>

<h4>类名</h4>

<p>毫无例外，类名要使用CapWords规范，只是内部使用的类，需要额外在名字前面加上下划线。</p>

<h4>异常名</h4>

<p>异常也是类，应该应用类名的规则，但是你应该在异常名前面增加后缀“Error”（如果这个异常确实是个错误的话）</p>

<h4>全局变量名</h4>

<p>（我们希望这些变量只在模块内部使用），命名规格跟函数大体类似。</p>

<p>被设计通过使用from M import * 来导入使用的模块，应该使用__all__来避免将所有名字全局导出，或者使用较老的前缀规范，即全局变量名前加下划线（来标识这些全局变量是模块非公有的）</p>

<h4>函数名</h4>

<p>函数名应该都小写，为了提高可读性，适当增加下划线。</p>

<p>mixedCase这种风格只允许用在已使用该风格的地方，保持风格的一致性。</p>

<h4>函数和方法参数</h4>

<p>永远使用self作为实例方法的第一个参数名。</p>

<p>永远使用cls作为类方法的第一个参数名。</p>

<p>如果一个函数的参数名与现有的关键字冲突，最好的解决办法是在名字后面加一个下划线，而不是使用缩写和拼写变体，例如class_要好于clss（最好是能够使用同义词来编码出现类似的冲突）</p>

<h4>方法名和实例成员变量</h4>

<p>使用函数的命名规则：全部小写，为了提高可读性，适当增加下划线。</p>

<p>使用一个前缀下划线来标识该方法和实例成员变量为非公有的。</p>

<p>为了避免与子类的命名冲突，使用2个前缀下划线来触发Python的名字扩展机制。</p>

<p>Python用类名来扩展这些名字：如果类Foo有一个属性__a，就不能通过Foo.<strong>a来访问(坚持要访问，则可以使用Foo._Foo</strong>a)。通常，双下划线前缀应该只用来避免与子类的名字冲突。</p>

<h4>注意：关于__names的使用还存在一些争论（见下文）</h4>

<h4>常量</h4>

<p>常量通常定义在模块的顶层，使用全大写作为名称，适当使用下划线分隔。例如：MAX_OVERFLOW和TOTAL。</p>

<h4>继承设计</h4>

<p>永远要考虑好方法和实例成员变量应该是公有的还是非公有的。如果不能确定，就选择非公有；将一个非公有的变为公有的要比将非公有的改为公有的容易。</p>

<p>公有属性是那些你期望与类无关的客户端来使用，并使用委托来保证向后兼容。非公有属性是那些不希望被第三方使用的属性，你不能保证这些非公有属性不会改变甚至移除。</p>

<p>在这里我们没有使用术语“private”，因为在Python里没有真正的非公有（避免了大量不必要的工作）。</p>

<p>另一类属性是那些成为子类API的部分（在其他语言中通常成为protected）。一些类是被设计用来作为其他的类的基类，要么被扩展要么被修改。当设计这样的类时，一定要弄清楚哪些属性是公有的，哪些属性是作为子类的API，而哪些是只被基类自己使用的。</p>

<p>下面是比较Pythonic的一些指导建议：</p>

<ul>
<li>公有属性不应该带有前缀下划线</li>
<li>如果你的公有属性名与关键字冲突，应该在名字后面加一个下划线后缀，而不是使用缩写和拼写变体（尽管如此，cls是一个最好的代表一个类的变量名，尤其类方法的第一个参数）</li>
<li>如果是简单的数据属性，应该直接暴露该属性，而不是定义读写该属性的方法。如果你发现要将一个简单的数据属性扩展成为函数行为，请记住Python提供了非常简便的方法来做这些未来加强。这种情况下，使用特性来隐藏属性存取函数的实现。</li>
</ul>


<p><em>注意1</em>:特性只能在新类中使用</p>

<p><em>注意2</em>:尽量避免使用函数行为引起的副作用，虽然例如缓存等副作用一般情况下不会有什么问题</p>

<p><em>注意3</em>:避免使用特性来做开销大的操作，因为属性记法会使调用者认为访问属性是开销很小的。</p>

<ul>
<li>如果你的类是设计成被用来继承的，而且其中有些属性你不希望被子类使用，那么你应该在这些属性的名字前增加双下划线前缀，但没有下划线后缀。这会触发Python的名字扩展算法，将类名扩展到属性名中，这能避免与子类的同名属性的冲突。</li>
</ul>


<p><em>注意1</em>:注意只有简单的类名才能使用在名字扩展中，如果子类拥有相同的类名和属性名，名字冲突还是会发生。</p>

<p><em>注意2</em>:名字扩展只能用在特定的用途中，比如调试和__getattr__()，不是很方便。然而名字扩展算法很详细的文档记载，而且很容易手工实现。</p>

<p><em>注意3</em>:并不是所有人都喜欢名字扩展，根据实际需要来使用。</p>

<h2>编程建议</h2>

<ul>
<li>不要以不利于某种Python实现的方式来写代码（PyPy, Jython, IronPython, Cython, Psyco等）</li>
</ul>


<p>比如，不要使用针对CPython优化过的字符串拼接语句，a += b 或者 a = a + b，这写语句在Jython中运行较慢。在一些注重性能的库中使用&#8217;&lsquo;.join()来代替。这样能保证在多种Python实现上运行都保证有线性时间。</p>

<ul>
<li>单个元素的比较例如None，应该永远使用is或者is not，不要使用等号。</li>
</ul>


<p>要小心if x的写法，如果你的本意是if x is not None。在测试一个默认为None的变量或者参数是否被设置为其他值时，这个值也许在布尔上下文中为false。</p>

<ul>
<li>当使用比较来实现排序操作时，最好是实现所有6个操作（__eq__, __ne__, __lt__, __le__, __gt__, __ge__），而不要依赖其他代码只会执行其中特定的比较。</li>
</ul>


<p>为了降低实现排序的复杂性，functools.total_ordering()装饰器提供了工具来生成缺失的比较操作。</p>

<p><a href="http://www.python.org/dev/peps/pep-0207/">PEP 207</a>指出Python承担了自反规则，解释器会将y > x替换为x &lt; y，y >= x替换为x &lt;= y，也会交换x == y 和 x != y两边的参数，sort()和min()操作会确保使用&lt;操作符，max()函数会确保使用>操作符。但是最好还是全部实现6个操作符，避免在其他地方引起混乱。</p>

<ul>
<li>使用基于类的异常</li>
</ul>


<p>字符串异常在新的代码中是被禁止的，在Python2.6中这个语言特性就被移除了。</p>

<p>模块或包应该定义它们自己特定域下面的异常基类。这些异常类应该继承自内置的Exception类，并且永远包含有文档字符串。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class MessageError(Exception):
</span><span class='line'>    """Base class for errors in the email package."""</span></code></pre></td></tr></table></div></figure>


<p>在这里应用了类名规范，即如果这个异常是个错误，你应该为你的异常类名增加Error后缀。非错误异常类名不需要额外的后缀。</p>

<ul>
<li>当抛出异常时，使用raise ValueError(&lsquo;message&rsquo;)，而不是使用 raise ValueError, &lsquo;message&#8217;这种旧形式。</li>
</ul>


<p>之所以选择带括号的形式，是因为异常的参数一般比较长或者带有字符串格式化符号，由于有括号，所以你不需要使用“\”来续行。在Python3中，第二种形式是非法的。</p>

<ul>
<li>当捕获异常时，可能的话尽量指定需要捕获的异常名，少用except:来捕获所有异常.</li>
</ul>


<p>例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>try:
</span><span class='line'>    import platform_specific_module
</span><span class='line'>except ImportError:
</span><span class='line'>    platform_specific_module = None</span></code></pre></td></tr></table></div></figure>


<p>一个只有except的异常捕获会捕获SystemExit和KeyboardInterrupt异常，会使程序变得难以使用Control-C来结束，并且会掩盖其他问题。如果你想捕获所有错误，可以使用except Exception:（只有except的捕获相当于except BaseException:）</p>

<p>比较好的做法是限制使用空except在以下2中情况下使用：</p>

<p>1.如果异常处理会打印堆栈信息，至少用户能知道发生了错误</p>

<p>2.如果代码需要做一些清理工作，但让异常继续往上抛出。其实在这种情况下使用try&hellip;finally是更好的选择</p>

<ul>
<li>此外，对所有使用 try/except语句的地方，要限制try中语句的数量，避免掩盖掉其他问题</li>
</ul>


<p>Yes:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>try:
</span><span class='line'>    value = collection[key]
</span><span class='line'>except KeyError:
</span><span class='line'>    return key_not_found(key)
</span><span class='line'>else:
</span><span class='line'>    return handle_value(value)</span></code></pre></td></tr></table></div></figure>


<p>No:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>try:
</span><span class='line'>    # Too broad!
</span><span class='line'>    return handle_value(collection[key])
</span><span class='line'>except KeyError:
</span><span class='line'>    # Will also catch KeyError raised by handle_value()
</span><span class='line'>    return key_not_found(key)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>如果要做除获取和释放资源外的事情，上下文操作符应该通过单独的函数或者方法来调用，例如：</li>
</ul>


<p>Yes:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>with conn.begin_transaction():
</span><span class='line'>    do_stuff_in_transaction(conn)</span></code></pre></td></tr></table></div></figure>


<p>No:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>with conn:
</span><span class='line'>    do_stuff_in_transaction(conn)</span></code></pre></td></tr></table></div></figure>


<p>后一个例子并没有提供任何信息来表明__enter__ 和 __exit__方法在一次处理以后做了除关闭连接以外的事情。在这个情况里，显示调用是比较重要的。</p>

<ul>
<li>使用字符串方法，而不要用string模块</li>
</ul>


<p>字符串方法总是运行地更快，而且跟unicode字符串使用同样的API，如果要跟Python2.0之前的代码做兼容可以不遵守这个规则。</p>

<ul>
<li>使用&#8217;&lsquo;.startswith() 和 &rsquo;&lsquo;.endswith()，而不要用字符串分片去检测字符串是否包含某个前缀或者后缀。</li>
</ul>


<p>使用startswith() 和 endswith()语义更明确，引起错误的可能性也更小。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Yes: if foo.startswith('bar'):
</span><span class='line'>No:  if foo[:3] == 'bar':</span></code></pre></td></tr></table></div></figure>


<p>有个例外是你的代码必须使用Python 1.5.2。</p>

<ul>
<li>用isinstance()来判断对象的类别，而不是用type()</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Yes: if isinstance(obj, int):
</span><span class='line'>
</span><span class='line'>No:  if type(obj) is type(1):</span></code></pre></td></tr></table></div></figure>


<p>当检测一个对象是不是一个字符串的时候，要注意，字符串也可能是一个unicode字符串。在Python2.3中，str和unicode拥有一个共同基类basestring，所以你可以这样判断：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if isinstance(obj, basestring):</span></code></pre></td></tr></table></div></figure>


<ul>
<li>对于序列（字符串，列表，元组），利用真值校验是否为false来判断序列是否为空：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Yes: if not seq:
</span><span class='line'>     if seq:
</span><span class='line'>
</span><span class='line'>No: if len(seq)
</span><span class='line'>    if not len(seq)</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>书写字符串常量时，不要依赖末尾的空格。这样的空格视觉上比较难区分，而且一些编辑器会去掉它们。</p></li>
<li><p>不要使用==将一个布尔变量跟True和False比较：</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Yes:   if greeting:
</span><span class='line'>No:    if greeting == True:
</span><span class='line'>Worse: if greeting is True:</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Python标准库将不会使用函数标注，因为那样会导致过早形成特定的标注风格。相反，留给用户去发掘和尝试有用的标注风格。</li>
</ul>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>“Python Enhancement Proposal”的缩写，意为Python提高建议<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>美国作者威廉·特伦克在《风格的要素》一书中确立了精确的英文写作规则，该书也被俗称为“斯特伦克和怀特”（Strunk and White）。<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
